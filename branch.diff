# Revision 4419
Index: include/compat/execinfo.h
===================================================================
--- include/compat/execinfo.h	(.../tags/varnish-2.0.5/varnish-cache)
+++ include/compat/execinfo.h	(.../branches/2.0/varnish-cache)
@@ -35,7 +35,6 @@
 
 int     backtrace(void **, int);
 char ** backtrace_symbols(void *const *, int);
-void    backtrace_symbols_fd(void *const *, int, int);
 
 #ifdef __cplusplus
 }
Index: include/vrt.h
===================================================================
--- include/vrt.h	(.../tags/varnish-2.0.5/varnish-cache)
+++ include/vrt.h	(.../branches/2.0/varnish-cache)
@@ -52,6 +52,7 @@
 	const char	*request;
 	double		timeout;
 	double		interval;
+	unsigned	exp_status;
 	unsigned	window;
 	unsigned	threshold;
 	unsigned	initial;
Index: configure.ac
===================================================================
--- configure.ac	(.../tags/varnish-2.0.5/varnish-cache)
+++ configure.ac	(.../branches/2.0/varnish-cache)
@@ -1,9 +1,9 @@
 # $Id$
 
 AC_PREREQ(2.59)
-AC_COPYRIGHT([Copyright (c) 2006-2008 Linpro AS / Verdens Gang AS])
+AC_COPYRIGHT([Copyright (c) 2006-2009 Linpro AS / Verdens Gang AS])
 AC_REVISION([$Id$])
-AC_INIT([Varnish], [2.0.5], [varnish-dev@projects.linpro.no])
+AC_INIT([Varnish], [2.0.6], [varnish-dev@projects.linpro.no])
 AC_CONFIG_SRCDIR(include/varnishapi.h)
 AM_CONFIG_HEADER(config.h)
 
@@ -175,6 +175,7 @@
 AC_CHECK_FUNCS([strlcat strlcpy])
 AC_CHECK_FUNCS([strndup])
 AC_CHECK_FUNCS([daemon])
+AC_CHECK_FUNCS([backtrace])
 AC_SYS_LARGEFILE
 
 save_LIBS="${LIBS}"
Index: doc/changes-2.0.5-2.0.6.xml
===================================================================
--- doc/changes-2.0.5-2.0.6.xml	(.../tags/varnish-2.0.5/varnish-cache)
+++ doc/changes-2.0.5-2.0.6.xml	(.../branches/2.0/varnish-cache)
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE group [
+<!ENTITY mdash "&#8212;">
+]>
+<!-- $Id$ -->
+<group from="2.0.5" to="2.0.6">
+  <subsystem>
+    <name>varnishd</name>
+
+    <change type="bug" ref="585">
+      <para>2.0.5 had an off-by-one error in the ESI handling causing
+      includes to fail a large part of the time. This has now been
+      fixed.</para>
+    </change>
+
+    <change type="bug" ref="584">
+      <para>Try harder to not confuse backends when sending them
+      backend probes.  We half-closed the connection, something some
+      backends thought meant we had dropped the connection.  Stop
+      doing so, and add the capability for specifying the expected
+      response code.</para>
+    </change>
+
+    <change type="bug">
+      <para>In 2.0.5, session lingering was turned on.  This caused
+      statistics to not be counted often enough in some cases.  This
+      has now been fixed.</para>
+    </change>
+
+    <change type="bug" ref="547">
+      <para>Avoid triggering an assert if the other end closes the
+      connection while we are lingering and waiting for another
+      request from them.</para>
+    </change>
+
+    <change type="bug" ref="577">
+      <para>When generating backtraces, prefer the built-in backtrace
+      function if such exists.  This fixes a problem compiling 2.0.5
+      on Solaris.</para>
+    </change>
+
+    <change type="enh" ref="572">
+      <para>Make it possible to specify the per-thread stack size.
+      This might be useful on 32 bit systems with their limited
+      address space.</para>
+    </change>
+
+    <change type="bug" ref="559">
+      <para>Document the <code>-C</code> option
+      to <code>varnishd</code>.</para>
+    </change>
+  </subsystem>
+</group>
Index: doc/changes-2.0.6.xml
===================================================================
--- doc/changes-2.0.6.xml	(.../tags/varnish-2.0.5/varnish-cache)
+++ doc/changes-2.0.6.xml	(.../branches/2.0/varnish-cache)
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<?xml-stylesheet type="text/xml" href="changes-html.xsl"?>
+<!DOCTYPE changelog [
+ <!ENTITY mdash "&#8212;">
+]>
+<!-- $Id$ -->
+<changelog xmlns:xi="http://www.w3.org/2001/XInclude">
+  <package>Varnish</package>
+  <version>2.0.6</version>
+
+  <xi:include href="changes-2.0.5-2.0.6.xml"/>
+</changelog>
Index: doc/Makefile.am
===================================================================
--- doc/Makefile.am	(.../tags/varnish-2.0.5/varnish-cache)
+++ doc/Makefile.am	(.../branches/2.0/varnish-cache)
@@ -1,6 +1,7 @@
 # $Id$
 
 CHANGELOGS = \
+	changes-2.0.6.html \
 	changes-2.0.5.html \
 	changes-2.0.4.html \
 	changes-2.0.3.html \
@@ -13,6 +14,7 @@
 	changes-1.0.4.html
 
 XML = \
+	changes-2.0.5-2.0.6.xml \
 	changes-2.0.4-2.0.5.xml \
 	changes-2.0.3-2.0.4.xml \
 	changes-2.0.2-2.0.3.xml \
Index: lib/libvarnish/tcp.c
===================================================================
--- lib/libvarnish/tcp.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ lib/libvarnish/tcp.c	(.../branches/2.0/varnish-cache)
@@ -239,8 +239,10 @@
 TCP_linger(int sock, int linger)
 {
 	struct linger lin;
+	int i;
 
 	memset(&lin, 0, sizeof lin);
 	lin.l_onoff = linger;
-	AZ(setsockopt(sock, SOL_SOCKET, SO_LINGER, &lin, sizeof lin));
+	i = setsockopt(sock, SOL_SOCKET, SO_LINGER, &lin, sizeof lin);
+	assert(i == 0 || errno == EBADF);
 }
Index: lib/libvarnishcompat/execinfo.c
===================================================================
--- lib/libvarnishcompat/execinfo.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ lib/libvarnishcompat/execinfo.c	(.../branches/2.0/varnish-cache)
@@ -28,6 +28,12 @@
 
 #include "config.h"
 
+#ifndef HAVE_BACKTRACE
+
+#include "compat/execinfo.h"
+
+#if defined (__GNUC__) && __GNUC__ >= 4	/* XXX Correct version to check for ? */
+
 #include <sys/types.h>
 #include <sys/uio.h>
 #include <dlfcn.h>
@@ -38,10 +44,9 @@
 #include <string.h>
 #include <unistd.h>
 
-#include "compat/execinfo.h"
 
-void *getreturnaddr(int);
-void *getframeaddr(int);
+static void *getreturnaddr(int);
+static void *getframeaddr(int);
 
 #define D10(x) ceil(log10(((x) == 0) ? 2 : ((x) + 1)))
 
@@ -132,51 +137,7 @@
     return rval;
 }
 
-#if 0
-void
-backtrace_symbols_fd(void *const *buffer, int size, int fd)
-{
-    int i, len, offset;
-    char *buf;
-    Dl_info info;
-
-    for (i = 0; i < size; i++) {
-        if (dladdr(buffer[i], &info) != 0) {
-            if (info.dli_sname == NULL)
-                info.dli_sname = "???";
-            if (info.dli_saddr == NULL)
-                info.dli_saddr = buffer[i];
-            offset = (const char *)buffer[i] - (const char *)info.dli_saddr;
-            /* "0x01234567 <function+offset> at filename" */
-            len = 2 +                      /* "0x" */
-                  (sizeof(void *) * 2) +   /* "01234567" */
-                  2 +                      /* " <" */
-                  strlen(info.dli_sname) + /* "function" */
-                  1 +                      /* "+" */
-                  D10(offset) +            /* "offset */
-                  5 +                      /* "> at " */
-                  strlen(info.dli_fname) + /* "filename" */
-                  2;                       /* "\n\0" */
-            buf = alloca(len);
-            if (buf == NULL)
-                return;
-            snprintf(buf, len, "%p <%s+%d> at %s\n",
-              buffer[i], info.dli_sname, offset, info.dli_fname);
-        } else {
-            len = 2 +                      /* "0x" */
-                  (sizeof(void *) * 2) +   /* "01234567" */
-                  2;                       /* "\n\0" */
-            buf = alloca(len);
-            if (buf == NULL)
-                return;
-            snprintf(buf, len, "%p\n", buffer[i]);
-        }
-        write(fd, buf, len - 1);
-    }
-}
-#endif
-
-void *
+static void *
 getreturnaddr(int level)
 {
 
@@ -313,7 +274,7 @@
     }
 }
 
-void *
+static void *
 getframeaddr(int level)
 {
 
@@ -449,3 +410,24 @@
     default: return NULL;
     }
 }
+
+#else
+
+int
+backtrace(void **buffer, int size)
+{
+	(void)buffer;
+	(void)size;
+	return (0);
+}
+
+char **
+backtrace_symbols(void *const *buffer, int size)
+{
+	(void)buffer;
+	(void)size;
+	return (0);
+}
+
+#endif /*  (__GNUC__) && __GNUC__ >= 4 */
+#endif /* HAVE_BACKTRACE */
Index: lib/libvcl/vcc_backend.c
===================================================================
--- lib/libvcl/vcc_backend.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ lib/libvcl/vcc_backend.c	(.../branches/2.0/varnish-cache)
@@ -341,11 +341,12 @@
 	struct token *t_field;
 	struct token *t_did = NULL, *t_window = NULL, *t_threshold = NULL;
 	struct token *t_initial = NULL;
-	unsigned window, threshold, initial;
+	unsigned window, threshold, initial, status;
 
 	fs = vcc_FldSpec(tl,
 	    "?url",
 	    "?request",
+	    "?expected_response",
 	    "?timeout",
 	    "?interval",
 	    "?window",
@@ -359,6 +360,7 @@
 	window = 0;
 	threshold = 0;
 	initial = 0;
+	status = 0;
 	Fb(tl, 0, "\t.probe = {\n");
 	while (tl->t->tok != '}') {
 
@@ -404,6 +406,17 @@
 			initial = vcc_UintVal(tl);
 			vcc_NextToken(tl);
 			ERRCHK(tl);
+		} else if (vcc_IdIs(t_field, "expected_response")) {
+			status = vcc_UintVal(tl);
+			if (status < 100 || status > 999) {
+				vsb_printf(tl->sb,
+				    "Must specify .status with exactly three "
+				    " digits (100 <= x <= 999)\n");
+				vcc_ErrWhere(tl, tl->t);
+				return;
+			}
+			vcc_NextToken(tl);
+			ERRCHK(tl);
 		} else if (vcc_IdIs(t_field, "threshold")) {
 			t_threshold = tl->t;
 			threshold = vcc_UintVal(tl);
@@ -455,6 +468,8 @@
 		Fb(tl, 0, "\t\t.initial = %u,\n", initial);
 	else
 		Fb(tl, 0, "\t\t.initial = ~0U,\n", initial);
+	if (status > 0)
+		Fb(tl, 0, "\t\t.exp_status = %u,\n", status);
 	Fb(tl, 0, "\t},\n");
 	ExpectErr(tl, '}');
 	vcc_NextToken(tl);
Index: lib/libvcl/vcc_fixed_token.c
===================================================================
--- lib/libvcl/vcc_fixed_token.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ lib/libvcl/vcc_fixed_token.c	(.../branches/2.0/varnish-cache)
@@ -246,13 +246,14 @@
 	vsb_cat(sb, "on\n */\n\nextern void *vrt_magic_string_end;\n");
 	vsb_cat(sb, "\nstruct vrt_backend_probe {\n\tconst char\t*url;\n");
 	vsb_cat(sb, "\tconst char\t*request;\n\tdouble\t\ttimeout;\n");
-	vsb_cat(sb, "\tdouble\t\tinterval;\n\tunsigned\twindow;\n");
-	vsb_cat(sb, "\tunsigned\tthreshold;\n\tunsigned\tinitial;\n");
-	vsb_cat(sb, "};\n\n/*\n * A backend is a host+port somewhere on the");
-	vsb_cat(sb, " network\n */\nstruct vrt_backend {\n");
-	vsb_cat(sb, "\tconst char\t\t\t*vcl_name;\n\tconst char\t\t\t*ident");
-	vsb_cat(sb, ";\n\n\tconst char\t\t\t*hosthdr;\n");
-	vsb_cat(sb, "\n\tconst unsigned char\t\t*ipv4_sockaddr;\n");
+	vsb_cat(sb, "\tdouble\t\tinterval;\n\tunsigned\texp_status;\n");
+	vsb_cat(sb, "\tunsigned\twindow;\n\tunsigned\tthreshold;\n");
+	vsb_cat(sb, "\tunsigned\tinitial;\n};\n\n/*\n");
+	vsb_cat(sb, " * A backend is a host+port somewhere on the network\n");
+	vsb_cat(sb, " */\nstruct vrt_backend {\n\tconst char\t\t\t*vcl_name");
+	vsb_cat(sb, ";\n\tconst char\t\t\t*ident;\n\n");
+	vsb_cat(sb, "\tconst char\t\t\t*hosthdr;\n\n");
+	vsb_cat(sb, "\tconst unsigned char\t\t*ipv4_sockaddr;\n");
 	vsb_cat(sb, "\tconst unsigned char\t\t*ipv6_sockaddr;\n");
 	vsb_cat(sb, "\n\tdouble\t\t\t\tconnect_timeout;\n");
 	vsb_cat(sb, "\tdouble\t\t\t\tfirst_byte_timeout;\n");
@@ -324,9 +325,9 @@
 
 	/* ../../include/vrt_obj.h */
 
-	vsb_cat(sb, "/*\n * $Id: vcc_gen_obj.tcl 4082 2009-05-19 07:14:00Z ");
-	vsb_cat(sb, "sky $\n *\n * NB:  This file is machine generated, DO ");
-	vsb_cat(sb, "NOT EDIT!\n *\n * Edit vcc_gen_obj.tcl instead\n");
+	vsb_cat(sb, "/*\n * $Id$\n");
+	vsb_cat(sb, " *\n * NB:  This file is machine generated, DO NOT EDI");
+	vsb_cat(sb, "T!\n *\n * Edit vcc_gen_obj.tcl instead\n");
 	vsb_cat(sb, " */\n\nstruct sockaddr * VRT_r_client_ip(const struct ");
 	vsb_cat(sb, "sess *);\nstruct sockaddr * VRT_r_server_ip(struct ses");
 	vsb_cat(sb, "s *);\nconst char * VRT_r_server_hostname(struct sess ");
Index: lib/libjemalloc/jemalloc_linux.c
===================================================================
--- lib/libjemalloc/jemalloc_linux.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ lib/libjemalloc/jemalloc_linux.c	(.../branches/2.0/varnish-cache)
@@ -243,7 +243,7 @@
 #  define SIZEOF_PTR_2POW	3
 #  define NO_TLS
 #endif
-#ifdef __sparc64__
+#ifdef __sparc__
 #  define PAGESIZE_2POW		13
 #  define QUANTUM_2POW		4
 #  define SIZEOF_PTR_2POW	3
@@ -272,6 +272,11 @@
 #  define QUANTUM_2POW		4
 #  define SIZEOF_PTR_2POW	2
 #endif
+#ifdef __s390x__
+#  define PAGESIZE_2POW		12
+#  define QUANTUM_2POW		4
+#  define SIZEOF_PTR_2POW	3
+#endif
 
 #define	QUANTUM			((size_t)(1U << QUANTUM_2POW))
 #define	QUANTUM_MASK		(QUANTUM - 1)
Index: redhat/varnish.spec
===================================================================
--- redhat/varnish.spec	(.../tags/varnish-2.0.5/varnish-cache)
+++ redhat/varnish.spec	(.../branches/2.0/varnish-cache)
@@ -1,12 +1,14 @@
 Summary: High-performance HTTP accelerator
 Name: varnish
-Version: 2.0.4
+Version: 2.0.6
 Release: 1%{?dist}
 License: BSD
 Group: System Environment/Daemons
 URL: http://www.varnish-cache.org/
 Source0: http://downloads.sourceforge.net/varnish/varnish-%{version}.tar.gz
 #Patch0: varnish.varnishtest_debugflag.patch
+#Patch1: varnish.s390x_pagesize.patch
+#Patch2: varnish.sparc_pagesize.patch
 BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)
 # The svn sources needs autoconf, automake and libtool to generate a suitable
 # configure script. Release tarballs would not need this
@@ -64,12 +66,13 @@
 %setup -q
 #%setup -q -n varnish-cache
 
-
 # The svn sources needs to generate a suitable configure script
 # Release tarballs would not need this
 #./autogen.sh
 
 #%patch0 -p0
+#%patch1 -p0
+#%patch2 -p0
 
 # Hack to get 32- and 64-bits tests run concurrently on the same build machine
 case `uname -m` in
@@ -92,7 +95,7 @@
 %build
 
 # Remove "--disable static" if you want to build static libraries 
-# jemalloc is not compatible with Red Hat's ppc64 RHEL5 kernel koji server :-(
+# jemalloc is not compatible with Red Hat's ppc* RHEL5 kernel koji server :-(
 %ifarch ppc64 ppc
 %configure --disable-static --localstatedir=/var/lib --disable-jemalloc
 %else
@@ -236,6 +239,21 @@
 %postun libs -p /sbin/ldconfig
 
 %changelog
+* Mon Dec 14 2009 Ingvar Hagelund <ingvar@linpro.no> - 2.0.6-1
+- New upstream release
+
+* Mon Nov 09 2009 Ingvar Hagelund <ingvar@linpro.no> - 2.0.5-1
+- New upstream release
+
+* Thu Aug 13 2009 Ingvar Hagelund <ingvar@linpro.no> - 2.0.4-4
+- Added a sparc specific patch to libjemalloc.
+
+* Sun Jul 26 2009 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 2.0.4-3
+- Rebuilt for https://fedoraproject.org/wiki/Fedora_12_Mass_Rebuild
+
+* Thu May 04 2009 Ingvar Hagelund <ingvar@linpro.no> - 2.0.4-2
+- Added a s390 specific patch to libjemalloc.
+
 * Fri Mar 27 2009 Ingvar Hagelund <ingvar@linpro.no> - 2.0.4-1
   New upstream release 2.0.4 
 
Index: bin/varnishtest/tests/v00005.vtc
===================================================================
--- bin/varnishtest/tests/v00005.vtc	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishtest/tests/v00005.vtc	(.../branches/2.0/varnish-cache)
@@ -2,6 +2,16 @@
 
 test "VCL: test backend probe syntax"
 
+# Check status definition
+varnish v1 -vcl {
+	backend b1 {
+		.host = "127.0.0.1";
+		.probe = {
+			.expected_response = 204;
+		}
+	}
+}
+
 # Check url definition
 varnish v1 -vcl {
 	backend b1 {
Index: bin/varnishtest/tests/c00031.vtc
===================================================================
--- bin/varnishtest/tests/c00031.vtc	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishtest/tests/c00031.vtc	(.../branches/2.0/varnish-cache)
@@ -0,0 +1,19 @@
+# Test that we get anything through at all
+#
+# $Id$
+
+test "Worker thread stack size setting"
+
+server s1 {
+	rxreq 
+	txresp
+} -start
+
+varnish v1 -arg "-p thread_pool_stack=131072" -vcl+backend {} -start
+
+client c1 {
+	txreq -url "/"
+	rxresp
+	expect resp.status == 200
+} -run
+
Index: bin/varnishtest/tests/e00017.vtc
===================================================================
--- bin/varnishtest/tests/e00017.vtc	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishtest/tests/e00017.vtc	(.../branches/2.0/varnish-cache)
@@ -0,0 +1,88 @@
+# $Id$
+
+test "Aggressive use of ESI include"
+
+
+server s1 {
+	rxreq 
+	txresp -body {
+		<html>
+		Before include
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/00"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/01"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/02"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/03"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/04"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/05"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/06"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/07"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/08"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/09"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/10"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/11"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/12"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/13"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/14"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/15"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/16"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/17"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/18"/>
+		<esi:include src="/some/very/long/url/with/dozen/of/information/for/esi/subquery/to/munch/and/also/to/try/to/make/object/workspace/explode/by/dumping/a/core/in/some/obscure/directory/on/my/file/system/19"/>
+		After include
+	}
+	rxreq 
+	txresp -body { Included file 00 }
+	rxreq 
+	txresp -body { Included file 01 }
+	rxreq 
+	txresp -body { Included file 02 }
+	rxreq 
+	txresp -body { Included file 03 }
+	rxreq 
+	txresp -body { Included file 04 }
+	rxreq 
+	txresp -body { Included file 05 }
+	rxreq 
+	txresp -body { Included file 06 }
+	rxreq
+	txresp -body { Included file 07 }
+	rxreq 
+	txresp -body { Included file 08 }
+	rxreq 
+	txresp -body { Included file 09 }
+	rxreq 
+	txresp -body { Included file 10 }
+	rxreq 
+	txresp -body { Included file 11 }
+	rxreq 
+	txresp -body { Included file 12 }
+	rxreq 
+	txresp -body { Included file 13 }
+	rxreq 
+	txresp -body { Included file 14 }
+	rxreq 
+	txresp -body { Included file 15 }
+	rxreq 
+	txresp -body { Included file 16 }
+	rxreq
+	txresp -body { Included file 17 }
+	rxreq 
+	txresp -body { Included file 18 }
+	rxreq 
+	txresp -body { Included file 19 }
+} -start
+
+varnish v1 -vcl+backend {
+	sub vcl_fetch {
+		esi;
+	}
+} -start
+
+client c1 {
+	txreq 
+	rxresp
+	expect resp.status == 200
+}
+
+client c1 -run
+varnish v1 -expect esi_errors == 0
Index: bin/varnishtest/tests/v00002.vtc
===================================================================
--- bin/varnishtest/tests/v00002.vtc	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishtest/tests/v00002.vtc	(.../branches/2.0/varnish-cache)
@@ -185,3 +185,11 @@
 	}
 }
 
+
+varnish v1 -badvcl {
+	backend b1 {
+		.host = "127.0.0.1";
+		.probe = { .expected_response = 13; }
+	}
+}
+
Index: bin/varnishtest/vtc.c
===================================================================
--- bin/varnishtest/vtc.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishtest/vtc.c	(.../branches/2.0/varnish-cache)
@@ -294,7 +294,7 @@
 static void
 cmd_random(CMD_ARGS)
 {
-	unsigned long l;
+	uint32_t l;
 	int i;
 
 	(void)cmd;
Index: bin/varnishd/cache_vrt_esi.c
===================================================================
--- bin/varnishd/cache_vrt_esi.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishd/cache_vrt_esi.c	(.../branches/2.0/varnish-cache)
@@ -384,7 +384,7 @@
 			memcpy(c, val.b, Tlen(val));
 			val.b = c;
 			val.e = val.b + s;
-			*val.e = '\0';
+			val.e[-1] = '\0';
 		}
 
 		if (Tlen(val) > 7 && !memcmp(val.b, "http://", 7)) {
Index: bin/varnishd/cache_panic.c
===================================================================
--- bin/varnishd/cache_panic.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishd/cache_panic.c	(.../branches/2.0/varnish-cache)
@@ -264,6 +264,8 @@
 	size_t i;
 
 	size = backtrace (array, 10);
+	if (size == 0)
+		return;
 	vsb_printf(vsp, "Backtrace:\n");
 	for (i = 0; i < size; i++) {
 		vsb_printf (vsp, "  ");
Index: bin/varnishd/mgt_pool.c
===================================================================
--- bin/varnishd/mgt_pool.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishd/mgt_pool.c	(.../branches/2.0/varnish-cache)
@@ -179,6 +179,13 @@
 		"number of worker threads.  ",
 		EXPERIMENTAL,
 		"3", "requests per request" },
+	{ "thread_pool_stack",
+		tweak_uint, &master.wthread_stacksize, 64*1024, UINT_MAX,
+		"Worker thread stack size.  In particular on 32bit systems "
+		"you may need to tweak this down to fit many threads into "
+		"the limited address space.\n",
+		EXPERIMENTAL,
+		"-1", "bytes" },
 	{ NULL, NULL, NULL }
 };
 
Index: bin/varnishd/cache_center.c
===================================================================
--- bin/varnishd/cache_center.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishd/cache_center.c	(.../branches/2.0/varnish-cache)
@@ -105,6 +105,7 @@
 			if (i == 0) {
 				WSL(sp->wrk, SLT_Debug, sp->fd, "herding");
 				VSL_stats->sess_herd++;
+				SES_Charge(sp);
 				sp->wrk = NULL;
 				vca_return_session(sp);
 				return (1);
Index: bin/varnishd/varnishd.c
===================================================================
--- bin/varnishd/varnishd.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishd/varnishd.c	(.../branches/2.0/varnish-cache)
@@ -209,6 +209,7 @@
 	fprintf(stderr, FMT, "-b address:port", "backend address and port");
 	fprintf(stderr, FMT, "", "   -b <hostname_or_IP>");
 	fprintf(stderr, FMT, "", "   -b '<hostname_or_IP>:<port_or_service>'");
+	fprintf(stderr, FMT, "-C", "print VCL code compiled to C language");
 	fprintf(stderr, FMT, "-d", "debug");
 	fprintf(stderr, FMT, "-f file", "VCL script");
 	fprintf(stderr, FMT, "-F", "Run in foreground");
Index: bin/varnishd/cache_pool.c
===================================================================
--- bin/varnishd/cache_pool.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishd/cache_pool.c	(.../branches/2.0/varnish-cache)
@@ -551,7 +551,7 @@
  */
 
 static void
-wrk_breed_flock(struct wq *qp)
+wrk_breed_flock(struct wq *qp, const pthread_attr_t *tp_attr)
 {
 	pthread_t tp;
 
@@ -564,7 +564,7 @@
 	    qp->nqueue > qp->lqueue)) {	/* not getting better since last */
 		if (qp->nthr >= nthr_max) {
 			VSL_stats->n_wrk_max++;
-		} else if (pthread_create(&tp, NULL, wrk_thread, qp)) {
+		} else if (pthread_create(&tp, tp_attr, wrk_thread, qp)) {
 			VSL(SLT_Debug, 0, "Create worker thread failed %d %s",
 			    errno, strerror(errno));
 			VSL_stats->n_wrk_failed++;
@@ -595,17 +595,27 @@
 wrk_herder_thread(void *priv)
 {
 	unsigned u, w;
+	pthread_attr_t tp_attr; 
 
+	/* Set the stacksize for worker threads */ 
+	AZ(pthread_attr_init(&tp_attr));
+
 	THR_SetName("wrk_herder");
 	(void)priv;
 	while (1) {
 		for (u = 0 ; u < nwq; u++) {
+			if (params->wthread_stacksize != UINT_MAX)
+				AZ(pthread_attr_setstacksize(&tp_attr,
+				    params->wthread_stacksize)); 
+
+			wrk_breed_flock(wq[u], &tp_attr);
+
 			/*
 			 * Make sure all pools have their minimum complement
 			 */
 			for (w = 0 ; w < nwq; w++)
 				while (wq[w]->nthr < params->wthread_min)
-					wrk_breed_flock(wq[w]);
+					wrk_breed_flock(wq[w], &tp_attr);
 			/*
 			 * We cannot avoid getting a mutex, so we have a
 			 * bogo mutex just for POSIX_STUPIDITY
@@ -613,7 +623,6 @@
 			Lck_Lock(&herder_mtx);
 			Lck_CondWait(&herder_cond, &herder_mtx);
 			Lck_Unlock(&herder_mtx);
-			wrk_breed_flock(wq[u]);
 		}
 	}
 }
Index: bin/varnishd/cache_backend_poll.c
===================================================================
--- bin/varnishd/cache_backend_poll.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishd/cache_backend_poll.c	(.../branches/2.0/varnish-cache)
@@ -173,23 +173,6 @@
 	}
 	vt->good_xmit |= 1;
 
-	/* And do a shutdown(WR) so we know that the backend got it */
-	i = shutdown(s, SHUT_WR);
-	if (i != 0) {
-		vt->err_shut |= 1;
-		TCP_close(&s);
-		return;
-	}
-	vt->good_shut |= 1;
-
-	/* Check if that took too long time */
-	t_now = TIM_real();
-	tmo = (int)round((t_end - t_now) * 1e3);
-	if (tmo < 0) {
-		TCP_close(&s);
-		return;
-	}
-
 	pfd->fd = s;
 	rlen = 0;
 	do {
@@ -236,7 +219,7 @@
 
 	i = sscanf(vt->resp_buf, "HTTP/%*f %u %s", &resp, buf);
 
-	if (i == 2 && resp == 200)
+	if (i == 2 && resp == vt->probe.exp_status)
 		vt->happy |= 1;
 }
 
@@ -335,6 +318,8 @@
 		vt->probe.window = 8;
 	if (vt->probe.threshold == 0)
 		vt->probe.threshold = 3;
+	if (vt->probe.exp_status == 0)
+		vt->probe.exp_status = 200;
 
 	if (vt->probe.threshold == ~0U)
 		vt->probe.initial = vt->probe.threshold - 1;
Index: bin/varnishd/cache_backend_poll.h
===================================================================
--- bin/varnishd/cache_backend_poll.h	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishd/cache_backend_poll.h	(.../branches/2.0/varnish-cache)
@@ -33,8 +33,6 @@
 BITMAP(good_ipv6, '6', "Good IPv6", 0)
 BITMAP( err_xmit, 'x', "Error Xmit", 0)
 BITMAP(good_xmit, 'X', "Good Xmit", 0)
-BITMAP( err_shut, 's', "Error Shut", 0)
-BITMAP(good_shut, 'S', "Good Shut", 0)
 BITMAP( err_recv, 'r', "Error Recv", 0)
 BITMAP(good_recv, 'R', "Good Recv", 0)
 BITMAP(happy,     'H', "Happy", 1)
Index: bin/varnishd/cache_acceptor.c
===================================================================
--- bin/varnishd/cache_acceptor.c	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishd/cache_acceptor.c	(.../branches/2.0/varnish-cache)
@@ -351,16 +351,46 @@
 	VSL(SLT_Debug, 0, "Acceptor is %s", vca_act->name);
 }
 
+/*--------------------------------------------------------------------*/
+
+static void
+ccf_listen_address(struct cli *cli, const char * const *av, void *priv)
+{
+	struct listen_sock *ls;
+	char h[32], p[32];
+
+	(void)cli;
+	(void)av;
+	(void)priv;
+	VTAILQ_FOREACH(ls, &heritage.socks, list) {
+		if (ls->sock < 0)
+			continue;
+		TCP_myname(ls->sock, h, sizeof h, p, sizeof p);
+		cli_out(cli, "%s %s\n", h, p);
+	}
+}
+
+/*--------------------------------------------------------------------*/
+
 static struct cli_proto vca_cmds[] = {
 	{ CLI_SERVER_START,	ccf_start },
 	{ NULL }
 };
 
+static struct cli_proto vca_debug_cmds[] = {
+	{ "debug.listen_address",
+	    "debug.listen_address",
+	    "Report the actual listen address\n", 0, 0,
+	    ccf_listen_address, NULL },
+	{ NULL }
+};
+
 void
 VCA_Init(void)
 {
 
 	CLI_AddFuncs(MASTER_CLI, vca_cmds);
+	CLI_AddFuncs(DEBUG_CLI, vca_debug_cmds);
 }
 
 void
Index: bin/varnishd/heritage.h
===================================================================
--- bin/varnishd/heritage.h	(.../tags/varnish-2.0.5/varnish-cache)
+++ bin/varnishd/heritage.h	(.../branches/2.0/varnish-cache)
@@ -94,6 +94,7 @@
 	unsigned		wthread_add_delay;
 	unsigned		wthread_fail_delay;
 	unsigned		wthread_purge_delay;
+	unsigned		wthread_stacksize;
 
 	unsigned		overflow_max;
 
Index: man/vcl.7so
===================================================================
--- man/vcl.7so	(.../tags/varnish-2.0.5/varnish-cache)
+++ man/vcl.7so	(.../branches/2.0/varnish-cache)
@@ -96,7 +96,6 @@
 To avoid overloading backend servers,
 .Fa .max_connections
 can be set to limit the maximum number of concurrent backend connections.
-.Ed
 .Pp
 The timeout parameters can be overridden in the backend declaration.
 The timeout parameters are
@@ -359,8 +358,8 @@
 .\" vcl_hash
 .It Cm vcl_hash
 Use
-.Cm req.hash += req.http.Set-Cookie
-or similar to include the Set-Cookie HTTP header in the hash string.
+.Cm req.hash += req.http.Cookie
+or similar to include the Cookie HTTP header in the hash string.
 The
 .Cm vcl_hash
 subroutine may terminate with one of the following keywords:
@@ -688,7 +687,7 @@
 
 sub vcl_fetch {
     if (obj.http.Set-Cookie) {
-        insert;
+        deliver;
     }
 }
 .Ed
